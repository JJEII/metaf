~~																															
~~		METa Alternate Format																					Created by	
~~			documentation																						 Eskarina	
~~																															

~~											
~~	TABLE OF CONTENTS:						
~~											
~~		1. VISUAL CODING ASSISTANCE			
~~		2. WHY metaf?						
~~		3. GETTING STARTED					
~~		4. META STRUCTURE					
~~		5. COMMENTS, STRINGS, MISCELLANEOUS	
~~		6. QUICK REFERENCE					
~~		7. FULL REFERENCE					
~~		8. VIRINDITANK FUNCTIONS			
~~											

~~ 1. VISUAL CODING ASSISTANCE																								

I strongly recommend you get Notepad++. Your metaf experience will be vastly improved. It's a powerful and free text editor
that can do custom coloring of text (along with several other capabilities I have leveraged). I have created a metaf.xml file
that colors all the relevant keywords, and activating that feature helps substantially.
	1) Download and install Notepad++ from here: https://notepad-plus-plus.org/downloads/
	2) Open it, go to the Language menu, then User Defined Language, and click Define your language...
	3) Click Import..., then navigate to and choose the metaf.xml file. Click Open.
	4) It should now be imported. Close Notepad++, and re-open it, then open this file in it.
Even this documentation file works better with that custom coloring activated. And, meta files work much, much better. So,
get that going as soon as possible! And, feel free to modify the coloration to your own preferences.

NOTE: If you prefer a 'dark mode' coloration style instead, I've also provided a metaf_dark.xml. Follow the instructions
above for it, then also go to the Settings menu, then Style Configurator... and select Language: Global Styles, then select
Style: Default Style, then swap the Foreground and Background colors in the 'Colour Style' box to make the default foreground
white, and background black. Click Save & Close. (Although, while you're in there, I'd also recommend changing a few other
styles' colors: 'Indent guideline style' Foreground (then 'More Colours...') RGB[81,81,81] and Background[0,0,0]; 'Brace
highlight style' Foreground[255,255,255] and Background[0,0,0]; 'Current line background'[28,28,66]; and 'Caret colour'
[191,128,255].)

I have leveraged Notepad++'s ability to suggest auto-completions based upon file-content-so-far, which should make entering
those long VirindiTank function names easier and less prone to error.

Notepad++ can auto-close brackets, braces, and parentheses if you tell it to. (Go to the Settings menu, then Preferences...,
and select Auto-Completion in the list on the left, then select your preferences.)

It can tab-in/out multiple lines simultaneously. (Select them, then press tab or shift-tab.)

It can simultaneously comment/uncomment multiple lines. (See the Edit menu, then Comment/Uncomment, and the Block options.)

~~ 2. WHY metaf?																											

VirindiTank is an impressive addon, but I became very frustrated while creating metas through its in-game editor. It is
possible to do so, of course, but it is agonizingly inefficient. I found that rather than spending much of my time thinking
about meta design, I was instead spending most of it just wrestling with the interface. The editor suffers from many
upsetting shortcomings, to include:
	* It can't reorder operations inside of rules (you just have to delete and re-enter, in a different order)
	* It can't change Any<-->All without purging the whole thing and re-entering everything inside it from scratch
	* It can't directly select text in fields, to copy/paste in and out of them
	* It can't display more than a short piece of a text field (and can't even scroll it!), so it's incredibly inefficient
	  to edit anything but the very shortest of text entries
	* It can't duplicate anything (operations, rules, or states) for subsequent minor modification
	* The interface is quite opaque (lacking transparency) in conveying a meta's logical structure
	* It artificially forces states to be ordered alphabetically
	* It can't search for anything (much less search-and-replace) to find where it appears within a meta
	* It doesn't have any sort of annotation capability (i.e., 'code comments')
	* And, I'm sure there are other things, but you get the idea

KEY: Long story, short: metaf suffers from none of the issues listed above. It's a much more friendly way to make metas.

That being said, there is one drawback of some significance that metaf has versus the in-game editor: you don't get instant
feedback on invalid text entries (e.g., expressions). Metaf does not parse the meaning of the inputs you provide; it simply
ensures the basic structure and datatypes are correct, while providing a powerful and transparent editing interface. So, if
you enter gevar[x] when you mean getvar[x], metaf will translate that into .met for VirindiTank to load, and you'll only
discover the mistake at that point. However, if you have already activated in Notepad++ the custom coloration I've provided,
you should have noticed something important just now: the correct function name is bold and a different color, so you can
know you got it right, even in metaf. (Every documented VirindiTank function does this. And, if you haven't yet activated
the custom colors... seriously: do it. Right now. It helps a ton.) I beleive this, in conjunction with the suggested auto-
completions, substantially reduce the impact of this drawback.

I think the only other shortcoming of metaf versus the in-game editor is also mixed with one of its strengths: building
navroutes. For obvious reasons, metaf is not good at adding new navroute nodes that have coordinates in them. (It simply
has no direct connection to Dereth's topography, so how could it?) However, it also has some great navroute strengths:
	* It is good at editing navroutes after those points have been collected
	* It is trivially easy to re-use navroutes in multiple places in metaf code while defining the navroute just one time
		- 'Code' and 'navroute' sections are listed separately in metaf. The way the two are linked is through a unique
		  'tag' that every navroute must have (e.g., nav73). The tag is used to cite which navroute to embed in an EmbedNav
		  operation. A single navroute tag can be cited by as many EmbedNav operations as you want, naming it whatever you
		  want in each location it's cited. Each tag's navroute is defined exactly one time in the 'navroute' section.
	* It is very simple to create EmbedNav placeholders in metaf code, ready to be filled in with coordinate content later
		- Place a single line in the navroute section---e.g., NAV: EmptyNav once---which defines an empty navroute with an
		  'EmptyNav' tag, then reference it anywhere you need to have an embedded navroute but don't yet have its content
		  ready---e.g., EmbedNav EmptyNav {[none]}. When you load it in-game, you'll have embedded navroutes everywhere you
		  need them, just waiting to be filled in.
	* For little additional effort, I created a layered-on feature: metaf can transform navroutes during translation into
	  .met. What that means is that for duplicate dungeons, you can create one nav, then simply transform it to create navs
	  for all the other dungeons with the same layout! Seven numbers = entirely new nav! For more, see EmbedNav in Section 7.
	* Also for relatively small effort, I added the ability for metaf to directly edit .nav files (without first being
	  embedded inside a .met file). Just remember that a nav-only file contains exactly one navroute. No more, no less.

One goal for metaf was to provide full-coverage support for the .met format. I believe I have achieved that. 'Success' is
not defined by 'the meta runs without errors' but rather by 'VirindiTank successfully loaded it'. (This in itself is
something of an achievement since a single out-of-place character in .met can trigger VirindiTank to refuse to load it,
simply stating that it's a corrupted file.) The inverse is also needed: 'metaf successfully translated .met to .af.'

~~ 3. GETTING STARTED																										

Running metaf requires that .NET Core be installed. Get it here: https://dotnet.microsoft.com/download
The three files (exe, dll, json) are also required in order to run. The metaf.xml file defines custom colors for Notepad++.
Finally, you'll likely need to authorize the file to run since I haven't formally published it with a digital signature.
(The only thing the program does is read a text-based file you tell it to, and write out another one in a different format.)

I have endeavoured to lower the learning curve as much as I can. metaf can literally translate between .met and .af files by
simply dragging either file type onto its metaf.exe icon. (It auto-detects the file type and translates it to the other
format, outputting a new file in the same directory as the one being translated.) However, that approach will never over-
write anything, instead creating a new and uniquely named output file every time, which may soon get a bit unwieldy if
you're actively developing a meta and repeatedly translating it to load in-game.

There is also a command line interface, and it just takes an input file name, followed (optionally) by an output file name.
If you use that instead, it will output to the specified file, whether or not it already exists. (So, be careful.)

The command line can take four other parameters as well: 'metaf -help' recreates this help file; 'metaf -new' creates a
blank template .af file that has the header text in it, ready for coding a meta; 'metaf -newnav' does the same for a
'nav .af'; 'metaf -version' outputs metaf's current version.

I have mapped all the in-game meta operations to a set of recognized text commands in metaf, used for translating back into
.met format. Sections 6 and 7 detail them.

TIP: If you're not sure how to express something in metaf that can be done directly in VirindiTank, then create it there,
then export it to the metaf format, and see what it looks like! In fact, that is my recommended first step for getting
started: export a .met to .af and have a look. However, I hope my references below generally provide sufficient explanations.

~~ 4. META STRUCTURE																										

The meta structure requires the definition of STATES, inside each of which is one or more RULES, each of which is composed
of an IF:-DO: pair. The IF: is a CONDITION, while the DO: is an ACTION (performed if the condition evaluates to True). Every
IF: and every DO: requires exactly one OPERATION to be contained within it, whether that operation be Never or None, or an
All/Any or DoAll that contains more operations wrapped inside of it. Each Condition triggers its corresponding Action if it
evaluates to true. (After all states have been defined, the navroute definitions are listed. NAV: marks the start of an
individual navroute, and any NODES inside the navroute appear on immediately subsequent lines, tabbed in one time.)

Each state must be uniquely named and appear exactly one time (and atomically, i.e., defined in full, and not split apart
into partial definitions spread throughout the file).

State order does not matter in metaf. Place them wherever works best for you. (Even move them around while developing, if
that helps.) Caveat: all states are listed above all navroutes.

Rule order within each state does matter, though. The top rule in each state has the highest priority, and each rule after
that descends on down the list in priority, to the lowest at the bottom.

When all states in the entire meta have been fully defined, all embedded navroutes are listed below them.

Proper tabbing is critical to metaf's code structure. It defines what's inside of what, in exactly the same way the in-game
editor allows. Pay attention to it.

TIP: Notepad++ supports tab/untab of multiple lines, en masse: just select the lines, and press tab or shift-tab (to untab).

I have leveraged the fact that every Condition and Action contains exactly one Operation to make the code more compact.
The logical code structure is like this:
	STATE: {Default}
	^	IF: 				<-- Almost totally blank line
	|		Any
	|			...
	|		DO:				<-- Almost totally blank line
	|			None
	|	IF:					<-- Almost totally blank line
	|	^	Always
	|	|	DO:				<-- Almost totally blank line
	|	|	^	DoAll
	|	|	|	^	...
	|	|	|	|	^		<-- Tabbing relationship is the same as below
But, I expect many rules (IF:-DO: pairs) to exist in most metas, so that would be a massive waste of code-viewing space,
just leaving every single IF: and DO: line essentially blank. Thus, I have condensed the code so that, even though it
continues to maintain its logical structure (and tab-in constraints), it is significantly more compact (especially across
many lines) due to requiring that the mandatory operation be on the same line as its rule label. Like this:
	STATE: {Default}
	^	IF: Any					<-- Now appears on same line as 'IF:'
	|			...			<-- Note: still tabbed-in three times, just like before
	|		DO:	None			<-- Now appears on same line as 'DO:'
	|	IF:	Always				<-- Now appears on same line as 'IF:'
	|	^	DO:	DoAll			<-- Now appears on same line as 'DO:'
	|	|	^	^	...		<-- Note: still tabbed-in four times, just like before
	|	|	|	|	^		<-- Tabbing relationship is the same as above
Note that the actual required tabbing remains the same in both! That's important because tab-in count determines logical
nesting of operations. So, even though the '...' at the bottom there appears to be tabbed in too far (two times beyond DO:,
rather than just one time), it's actually correct, because it's inside of both DO: and DoAll.

The one and only exception to this tab-in rule is the Not operation, which imposes no cumulatively additional tab-in demands
upon the following operation(s). So, if a line with, say, Any is tabbed in four times, then the following lines defining the
operations it encloses must be tabbed-in five times. And, this is also true of a four-tabbed Not Any line, as well as a four-
tabbed Not Not ... Not Any line: the line following is tabbed in five times.

TIP: Because metaf uses a similar code-structure style to the Python language (tabbing means something), you can actually
leverage this fact in Notepad++. While you do lose the custom coloration by doing this, if you set the language to Python
instead of metaf, you can get code-folding for free. (Getting both simultaneously requires writing a custom lexer.)

Once all states are defined, all navroutes (NAV:) are listed below. And, just like with states, the navroute order does not
matter; but just likes with rules in each state, the order of the nav nodes in each navroute does matter.

~~ 5. COMMENTS, STRINGS, MISCELLANEOUS																						

The metaf system supports line commenting. Just put a double-tilde (two ~) anywhere, and the rest of that line is ignored.

Many of the Operation inputs are essentially freeform text strings--from regular expressions to state names and more. In
order to unambiguously identify these inputs as they're intended, metaf requires that strings be delimited by braces { }.
Strings should also be separated by at least one whitespace character (e.g., space or tab). If you need to include braces
inside of a string input, you can do so: simply double it. In other words, when inside a string, {{ in metaf becomes { in
met, and }} becomes }. (Single braces aren't allowed inside metaf strings; if they're there at all, they must be doubled.)

Blank (whitespace-only) lines are ignored. Use them to your advantage if they improve readability.

NOTE: metaf expects decimal numbers to use periods as their decimal separator characters. If you live in a country that uses
commas instead, be aware of that. (.NET defaults to using the local culture for number formatting, which caused metaf to
break in those countries because .met always uses periods (I think). I have now forced .NET it to remain culture-invariant
for metaf, wherever it runs, so that it won't break anymore; but it does require periods, not commas.)

NOTE: When metaf exports from .met to .af, it includes a large comment header. There are multiple reasons for this, but the
main two are these: A) Convenient metaf keyword reference, and B) Notepad++ provides predictive auto-completion of words
based upon what's already been entered into a document, so including all VirindiTank function names and all metaf keywords
right at the start achieves a sort of 'poor man's IntelliSense' that should help with getting them input correctly while
coding your metas (especially the very long VT function names).

~~ 																															
~~ 6. QUICK REFERENCE																										
~~ 																															

	~~ Data-type abbreviations:		
		i - Integer. A whole number.
		h - Integer expressed in Hexidecimal.
		d - Double. A decimal number.
		s - String. A chain of arbitrary characters inside braces { }. Can't contain braces, unless doubled.
		r - RegEx. Same as S, but expected to be a Regular Expression.
		l - Literal. A chain of characters beginning with a letter or underscore, followed by zero or more letters,
			underscores, or digits. Note: cannot contain any whitespace.
		p - Operation (Condition or Action).

	~~ STATE, RULE					
				 STATE: - Input: s Name, Rule+ (indirectly). A state name, distinct from all other state names. Every state
						  must contain at least one Rule (IF-DO pair).
					IF: - Input: p Condition. Condition may be any type (including Any/All, which may contain more inside).
						  Every Condition (IF) must be followed by an Action (DO).
					DO: - Input: p Action. Action may be any type (including DoAll, which may contain more inside).

	~~ CONDITION operations (IF:)	
				  Never - Input: none. False. (Never do the Action.)
				 Always - Input: none. True. (Always do the Action.)
					All - Input: p* Conditions (none directly). Contains >=0 Condition operations inside it. True if All of
						  them are true. (Empty-All is true; Not empty-All is false.)
					Any - Input: p* Conditions (none directly). Contains >=0 Condition operations inside it. True if Any of
						  them are true. (Empty-Any is false; Not empty-Any is true.)
			  ChatMatch - Input: r Pattern. True if Pattern matches a ChatWindow string.
			MainSlotsLE - Input: i Count. True if number of slots remaining empty in your inventory's main pack <= Count.
		  SecsInStateGE - Input: i Seconds. True if time since meta entered this state >= Seconds. (Timer RESETS if meta
						  turned off/on.)
			   NavEmpty - Input: none. True if the current navroute is empty.
				  Death - Input: none. True if character death is detected.
			 VendorOpen - Input: none. True when any vendor window is opened. !!! check exact functionality
		   VendorClosed - Input: none. True when a vendor window is closed. !!! check exact functionality
			ItemCountLE - Input: i Count, s Item name. True if number of Item in your inventory <= Count.
			ItemCountGE - Input: i Count, s Item name. True if number of Item in your inventory >= Count.
		MobsInDist_Name - Input: i Count, d Distance, r monster Name. True if number of Name within Distance >= Count.
	MobsInDist_Priority - Input: i Count, d Distance, i monster Priority. True if number of monsters of exact-Priority
						  within Distance >= Count.
			 NeedToBuff - Input: none. True if VTank's evaluated settings determine you need to buff.
		   NoMobsInDist - Input: d Distance. True if no monsters (>-1??) are within Distance of character. !!! test
				 BlockE - Input: h Landblock (expressed in hexidecimal). True if character's current landblock matches.
				  CellE - Input: h Landcell (expressed in hexidecimal). True if character's current landcell matches.
			 IntoPortal - Input: none. True upon entering portalspace.
			 ExitPortal - Input: none. True upon exiting portalspace.
					Not - Input: p Condition. Logically inverts any single Condition operation (including All/Any (empty or
						  not), as well as another Not). True if that operation is false.
		 PSecsInStateGE - Input: i Seconds. True if time since meta entered this state >= Seconds. (Timer CONTINUES if meta
						  turned off/on. P=Persistent.)
		  SecsOnSpellGE - Input: i Seconds, i SpellID(?). True if time remaining on spell with SpellID >= Seconds.
			BuPercentGE - Input: i Percent burden. True if character's burden >= Percent.
			DistToRteGE - Input: d Distance. True if character's shortest distance to currently loaded navroute >= Distance.
				   Expr - Input: s VTank 'code Expression'. True when executing Expression evaluates to true.
			ChatCapture - Input: r Pattern, s Color id list. True if ChatWindow message matches Pattern and Color. 'Captures'
						  regex groups in named variables.

	~~ ACTION operations (DO:)		
				   None - Input: none. Do nothing.
			   SetState - Input: s meta State name. Transition to State.
				   Chat - Input: s Text. Input the Text into the ChatWindow. (@t messages, execute vt commands, @e, etc.)
				  DoAll - Input: p* Actions (none directly). Contains >=0 Action operations inside it, allowing multiple
						  Actions to be associated with a single Condition.
			   EmbedNav - Input: s Tag, s Name, optional s Transform. Tag is a just a handle for a nav listed in the file's
						  bottom section; Name shows as the embedded nav's name in-game. See EmbedNav in Section 7 for more
						  on optional Transform input.
			  CallState - Input: s 'GoTo state name', s 'ReturnTo state name'. Transitions to GoTo state, placing ReturnTo
						  state on stack (set-up for use by a later Return operation).
				 Return - Input: none. Pops state from top of 'return to' stack and transitions to that state.
				 DoExpr - Input: s 'code Expression'. Executes the Expression as 'action code'.
			   ChatExpr - Input: s Text. Text is a hybrid; it first evaluates as an expression, then is input to ChatWindow.
						  Enables variable inputs to chat commands.
			SetWatchdog - Input: d Distance, d Seconds, s State name. In a state, if character hasn't moved >=Distance for
						  Seconds of time, call State.
		  ClearWatchdog - Input: none. Clears watchdog for this state.
				 GetOpt - Input: s VTank Option, s Variable name. Gets current value of Option and saves it in Variable.
				 SetOpt - Input: s VTank Option, s Expression. Sets Option based upon result of evaluating Expression.
			 CreateView - Input: s View, s XML. Creates a view View, with characteristics defined in XML. Note: the XML
						  must not contain newlines. Just like VirindiTank requires, so does metaf. (The XML must all be
						  on the same line as its CreateView operation.)
			DestroyView - Input: s View. Destroys the designated View.
		DestroyAllViews - Input: none. Destroys all existing Virindi Views for this meta.

	~~ NAV TYPES (NAV:)				
				   NAV: - Input: l Tag, l Type. Tag is distinct from all other nav tags. Type is one of the following:
				   circular - A navroute that infinitely repeats itself by looping back to the start when it hits the end.
					 linear - A navroute that infinitely repeats itself by alternatingly running it forward and backward.
					 follow - A navroute that is a single node in length (see below), to chase a specified player.
					   once - A navroute that does not repeat. Nodes are consumed (disappear) when they are reached.
					Every nav is listed in the nav section, which appear below the code listing section.

	~~ NAV NODE FORMATS				
				 Follow - flw   h Target GUID   {s Target Name}
				  Point - pnt   d X   d Y   d Z
		   Recall Spell - rcl   d X   d Y   d Z   {s Full Name of Recall Spell}
				  Pause - pau   d X   d Y   d Z   d Pause (in ms)
		ChatField (any) - cht   d X   d Y   d Z   {s ChatInput}
			 Use Vendor - vnd   d X   d Y   d Z   h Target GUID   {s Target Name}
		 Use Portal/NPC - ptl   d X   d Y   d Z   d TargetX   d TargetY   d TargetZ   i Target ObjectClass   {s Target Name}
		    Talk to NPC - tlk   d X   d Y   d Z   d TargetX   d TargetY   d TargetZ   i Target ObjectClass   {s Target Name}
		 Nav Checkpoint - chk   d X   d Y   d Z
			   Nav Jump - jmp   d X   d Y   d Z   d HeadingInDegrees   {s HoldShift (True|False)}   d Delay (in ms)

~~																															
~~ 7. FULL REFERENCE																										
~~																															

	~~ Miscellanous																											
		
		A couple things in this document, not explained elsewhere:
			GUID -  Globally Unique Identifier; it's an integer the game uses to reference every object uniquely. (Every
					object has a different number from every other object.) It is expressed in hexidecimal format, just like
					landblocks and landcells.
			ObjectClass - This is an integer that specifies a general 'object type' (e.g., Portal, NPC, etc.) See here for
					more: http://www.virindi.net/wiki/index.php/Meta_Expressions#Object_Properties

	~~ Datatype abbreviations																								

		i - Integer. A whole number.
		h - Integer expressed in Hexidecimal.
		d - Double. A decimal number.
		s - String. A chain of arbitrary characters inside braces { }. Can't contain braces, unless doubled.
		r - RegEx. Same as S, but expected to be a Regular Expression.
		l - Literal. A chain of characters beginning with a letter or underscore, followed by zero or more letters,
			underscores, or digits. Note: cannot contain any whitespace.
		p - An Operation (Condition or Action).

	~~ STATE, RULE																											

		STATE:   {s Name}   (Rule+ indirectly)
				DETAILS: Two inputs, one direct (on the same line) and one indirect (on subsequent lines). The direct input,
				Name, declares this state's name and must be distinct from all other state names. The indirect input, Rule+,
				indicates that every state must contain at least one Rule (IF-DO pair) on the following lines.
				EXAMPLE: STATE: {Hello, world.}
							IF: Never
								DO: None
						--> Defines a state named 'Hello, world.' containing a single rule (IF-DO pair) that does nothing.
						
		IF:   p Condition
				DETAILS: One input. Condition may be any type (including Any/All, which may contain more inside). Every
				Condition (IF) must be followed by an Action (DO).
				EXAMPLE: IF: Any
								Always
						--> Defines a Condition containing an Any operation (which itself contains an Always operation).

		DO:   p Action
				DETAILS: One input. Action may be any type (including DoAll, which may contain more inside).
				EXAMPLE: DO: DoAll
								EmbedNav MyFavorite follow
						--> Defines an Action containing a DoAll operation (which itself contains an EmbedNav operation).

	~~ CONDITION operations (IF:)																							

		All   (none directly)
				DETAILS: No direct inputs (on the same line) but does wrap zero or more Condition operations inside it (on
				following lines, tabbed in one more time). True if all directly-wrapped operations are True. (Empty-All is
				true; Not empty-All is false.) Do not confuse this with the Action DoAll.
				EXAMPLE: All
							Never
							Always
						 --> The All evaluates to False because not all the operations inside it
							 evaluate to True. (Never evaluates to False.)

		Always   (none)
				DETAILS: No inputs. True always. (Always do the corresponding Action.)
				EXAMPLE: Always
						 --> Always is True. (Always True.)

		Any   (none directly)
				DETAILS: No direct inputs (on the same line) but does wrap zero or more Condition operations inside it (on
				following lines, tabbed in one more time). True if any directly-wrapped operations are True. (Empty-Any is
				false; Not empty-Any is true.)
				EXAMPLE: Any
							Never
							Always
						 --> The Any evaluates to True because at least one operation inside it evaluates to True. (Always
							 evaluates to True.)

		BlockE   h Landblock
				DETAILS: One input. True if character location is currently in Landblock.
				EXAMPLE: BlockE 8B370000
						 --> True if leading 4 'digits' of character's @loc match leading 4 'digits'.

		BuPercentGE   i Burden
				DETAILS: One input. True if character burden percent is >= Burden.
				EXAMPLE: BuPercentGE 110
						 --> True if character burden is >= 110%.

		CellE   h Landcell
				DETAILS: One input. True if character location is currently in Landcell.
				EXAMPLE: CellE 8B37E3A1
						 --> True if all 8 'digits' of character's @loc match all 8 'digits'.

		ChatCapture   {r Pattern}   {s ColorIdList}
				DETAILS: Two inputs. True if both Pattern matches a ChatWindow message and that message's color is in the
						 ColorIdList. (Empty fields for either/both count as a match for that field.) Used to 'capture' text
						 into internal variables, which are given the names designated within Pattern with capturegroup_
						 concatenated as a prefix. The message color is in variable capturecolor, and the list is specified
						 as semicolon-separated numbers. See: http://www.virindi.net/wiki/index.php/Virindi_Chat_System_5
						 NOTE: It does not appear to actually be color IDs, but rather the various ChatWindow message type
						 IDs. (I matched to General and Trade, then changed their colors, and they still matched.)
								Colors I've discovered so far (and maybe correctly identified?):
										EnemyDeath				0					?							?
										?						1					?							?
										Say						2					MagicCast					17
										YouThink				3					Allegiance					18
										YouTell					4					Fellowship					19
										?						5					?							20
										HoT/Surge				6					YouEvaded/WereHitByEnemy	21
										YouResist(&HitByMagic?)	7					EnemyEvaded/WasHitByYou		22
										?						8					@hom						23
										?						9					Tinker Applied				24
										?						10					General						27
										?						11					Trade						28
										Emote					12					?							?
										?						13					?							?
										?						14					?							?
										?						15					?							?
				EXAMPLE: ChatCapture {^.*(?<who>Eskarina).* (says|tells you), \".+\"$} {2;4}
						--> When True:	Variable capturegroup_who holds string 'Eskarina';
									 	Variable capturecolor holds matched-message's colorID.

		ChatMatch   {r Pattern}
				DETAILS: One input. True if Pattern regex matches a ChatWindow message. (Matches any message if empty.)
				EXAMPLE: ChatMatch {^.*Eskarina.* (says|tells you), \".+\"$}
						 --> Simply detects a regex match in the ChatWindow. Does not capture anything.

		Death   (none)
				DETAILS: No inputs. True if character death detected.
				EXAMPLE: Death
						 --> Triggered on character death.

		DistToRteGE   d Distance
				DETAILS: One input. True if character's shortest-distance to current navroute is >= Distance (in yards).
				EXAMPLE: DistToRteGE
						 --> True when character exceeds  distance from current navroute.

		ExitPortal   (none)
				DETAILS: No inputs. True upon exiting portalspace.
				EXAMPLE: ExitPortal
						 --> True when character leaves portalspace.

		Expr   {s Code}
				DETAILS: One input. True if Code evaluates to True. Do not confuse this with the Action DoExpr.
				EXAMPLE: Expr {7==getobjectinternaltype[getvar[myvar]]}
						 --> True if variable myvar is an object type.
						(See: http://www.virindi.net/wiki/index.php/Meta_Expressions#Function_Information )

		IntoPortal   (none)
				DETAILS: No inputs. True upon entering portalspace.
				EXAMPLE: IntoPortal
						 --> True when character enters portalspace.

		ItemCountGE   i Count   {s Item}
				DETAILS: Two inputs. True if number of Item in inventory is >= Count. Is not a regex.
				EXAMPLE: ItemCountGE 25 {Prismatic Taper}
						 --> True when Prismatic Taper supply in inventory is >= 25.

		ItemCountLE   i Count   {s Item}
				DETAILS: Two inputs. True if number of Item in inventory is <= Count. Is not a regex.
				EXAMPLE: ItemCountLE 25 {Prismatic Taper}
						 --> True when Prismatic Taper supply in inventory is <= 25. (Uh-oh!)

		MainSlotsLE   i Count
				DETAILS: One input. True if number of empty slots remaining in character's main pack
				inventory is <= Count.
				EXAMPLE: MainSlotsLE 7
						 --> True when <=7 inventory slots remain empty in character's main pack.

		MobsInDist_Name   i Count   d Distance   {r Name}
				DETAILS: Three inputs. True if number of (regex-match) monster Name within Distance is >= Count. Completely
				ignores monster priority (including if it's -1).
				EXAMPLE: MobsInDist_Name 5 13.7 {Drudge Lurker}
						 --> True when >=5 Drudge Lurkers are within 13.7 yards of character.

		MobsInDist_Priority   i Count   d Distance   i Priority
				DETAILS: Three inputs. True if number of exact-Priority monsters within Distance is >= Count.
				EXAMPLE: MobsInDist_Priority 6 4.7 2
						 --> True when >=6 monsters of priority >=2 are within 4.7 yards of character.

		NavEmpty   (none)
				DETAILS: No inputs. True if current navroute is empty.
				EXAMPLE: NavEmpty
						 --> True when the current navroute is empty.

		NeedToBuff   (none)
				DETAILS: No inputs. True if VTank's settings determine character needs to buff.
				EXAMPLE: NeedToBuff
						 --> True when VTank's settings determine the character requires buffing.

		Never   (none)
				DETAILS: No inputs. Never True. (Never do the corresponding Action.)
				EXAMPLE: Never
						 --> Never is False. (Never True.)

		NoMobsInDist   d Distance
				DETAILS: One input. True if there are no monsters within Distance of character. Ignores Priority entirely.
				EXAMPLE: NoMobsInDist 20.6
						 --> True when no mobs are within 20.6 yards of character.

		Not   p Condition
				DETAILS: One input. True if Condition operation is False. (May be All or Any.)
				EXAMPLE: Not All
							Always
							Never
						 --> The Not is True because it inverts the All, which is False.

		PSecsInStateGE   i Seconds
				DETAILS: One input. True if time elapsed since entering current state >= Seconds.
				Persistent timer; does not reset if meta is stopped/started.
				EXAMPLE: PSecsInStateGE 15
						 --> True 15 seconds after entering (and staying in) the rule's state, whether or not the meta's
							 execution is turned off/on.

		SecsInStateGE   i Seconds
				DETAILS: One input. True if time elapsed since entering current state >= Seconds. Resets timer if meta is
				stopped/started.
				EXAMPLE: SecsInStateGE 12
						 --> True 12 seconds after entering (and staying in) the rule's state, so long as the meta has
							 been running the whole time. (It resets the timer counter to zero if the meta is turned off
							 and back on, as if it's just entered the state.)
				
		SecsOnSpellGE   i Seconds   i SpellID
				DETAILS: Two inputs. True if time remaining on spell with SpellID is >= Seconds.
				EXAMPLE: SecsOnSpellGE 120 4291
						 --> True if >=120 seconds remain on 'Incantation of Armor Self', which has a SpellID of 4291.
							 (Execute a '/vt dumpspells' command in-game. The far left column of the file it creates is the
							 SpellID column.)
				
		VendorOpen   (none)
				DETAILS: No inputs. True when any vendor window is opened.
				EXAMPLE: VendorOpen
						 --> True if any vendor window is open.

		VendorClosed   (none)
				DETAILS: No inputs. True when a vendor window is closed.
				EXAMPLE: VendorClosed
						 --> True when vendor window is closed.

	~~ ACTION operations (DO:)																								

		CallState   {s ToState}   {s ReturnState}
				DETAILS: Two inputs. Transitions to state ToState, placing ReturnState on the 'call stack' in order to
				remember where to go when ready to return. (See: Return.) Keep CallState and Return in careful balance.
				EXAMPLE: CallState {Do Something} {Done With Something}
						 --> Sets state to state 'Do Something', pushing 'Done With Something' onto the call stack, for later
							 popping, to 'return'.

		Chat   {s Text}
				DETAILS: One input. 'Send' Text as Chat. Do not confuse this with the Action ChatExpr.
				EXAMPLE: Chat {/vt jump 137 true 648}
						 --> The text is entered into and 'sent' to the ChatWindow, causing VTank to turn your character to
							 face a heading of 137 degrees, and then shift-jump after 'holding space' for 648 milliseconds.

		ChatExpr   {s ChatCode}
				DETAILS: One input. Evaluates ChatCode as a 'code', then 'sends' it to ChatWindow. Do not confuse this with
				the Action Chat.
				EXAMPLE: ChatExpr {\/t +getcharstringprop[1]+\, Hi\!}
						 --> Character @tells itself, 'Hi!'

		DoAll   (none directly)
				DETAILS: No direct inputs (on the same line) but does wrap zero or more Action operations inside it (on
				following lines, tabbed in one more time). Do not confuse with Condition All.
				EXAMPLE: DoAll
							Chat {/t Eskarina, Hi!}
							Chat {*dance*}
						 --> Sends Eskarina a direct message of 'Hi!', then emote-dances.

		DoExpr   {s Code}
				DETAILS: One input. Executes Code. Do not confuse this with the Condition Expr, or the Action ChatExpr.
				EXAMPLE: DoExpr {setvar[mycoords,getplayercoordinates[]]}
						 --> Sets variable mycoords to character's current coordinates (coordinate object).

		EmbedNav   l Tag   {s Name} {s Transform (optional)}
				DETAILS: Two inputs (or three). Tag is only used as a 'handle' to reference a navroute in the list of navs at
				the bottom of a metaf file, where it is marked with the same Tag. Name is the name displayed in-game, when
				you examine the embedded name in the meta. Note that Tag can be anything you want it to be, so long as it's a
				valid literal and is distinct from all other nav tags. (There's no reason it needs to be nav## in
				format; it could just as easily be OlthoiMatronHive instead.) The optional Transform input is a string
				containing seven doubles, separated by spaces: {a b c d e f g}, where
							New					Old
							[x]	  [ a   b  {0)] [x]   [e]
							[y] = [ c   d  (0)] [y] + {f]
							[z]	  [(0) (0) (1)] [z]   [g].
				Every nav node with coordinates in it gets transformed accordingly during translation into .met. The default
				transformation is {1 0 0 1 0 0 0}, which leaves points unchanged.
				EXAMPLE (REAL):	STATE: {Hive120}
									IF:	Never
										DO:	EmbedNav navH120 {H120}
								STATE: {Hive90}
									IF:	Never
										DO:	EmbedNav navH120 {H90} {1 0 0 1 0 -0.8 0}
						 --> The first EmbedNav (two inputs) references a complicated nav tagged as navH120, defined in the
							 nav section at the bottom of the file, and named 'H120' where it's embedded in the code. It
							 was created in Matron Hive East (120+), and it gets transformed with the default transform
							 when being translated into .met. The second EmbedNav (three inputs) references the same nav
							 as the first (still navH120), but two important differences happen here when translating into
							 .met: first, this nav gets named 'H90' where it's embedded in the code, and second, that third
							 input gets applied as a transform to all the nav nodes. That is the correct transform to put
							 it exactly in the same relative placement within Matron Hive West (90+) as it was in Matron
							 Hive East (120+). And, that's it. Those seven numbers created an entirely new nav.
							 In case you're wondering: South(40+) is {1 0 0 1 1.6 0 0} and North(60+) is {1 0 0 1 1.6 0.8 0}.

		None   (none)
				DETAILS: No inputs. Do nothing. (Action: None.)
				EXAMPLE: None
						 --> Nothing happens.

		Return   (none directly)
				DETAILS: No direct inputs but does expect a state to be on the 'call stack' because it needs to pop a
				state from the stack in order to transition the meta to whatever that state is. (See CallState.) Keep
				CallState and Return in careful balance.
				EXAMPLE: CallState {Do Something} {Done With Something}
						 --> Sets state to state 'Do Something', pushing 'Done With Something' onto
							 the call stack, for later popping, to 'return'.

		SetState   {s Name}
				DETAILS: One input. Set current state to state Name.
				EXAMPLE: SetState {Target Name}
						 --> Meta transitions to state 'Target Name'.

		SetWatchdog   d Distance   d Seconds   {s State name}
				DETAILS: Three inputs. You can set a watchdog in a state that is triggered if at any time while in that
				state your character has not moved >=Distance over the preceding Seconds of time. If triggered, State is
				called. (Returning from it, re-enters the original state.)
				EXAMPLE: SetWatchdog 12.3 4.6 {Oh, no!}
						--> If at some point while in the current state your character hasn't moved at least 12.3 yards in
							the preceding 4.6 seconds, state 'Oh, no!' is called.

		ClearWatchdog   (none)
				DETAILS: No inputs. Clears the watchdog for the current state.
				EXAMPLE: ClearWatchdog
						--> Clears (gets rid of) the current watchdog in this state (if any).

		GetOpt   {s Option}   {s Variable}
				DETAILS: Two inputs. Gets the current value of the VirindiTank Option and saves it in Variable.
				EXAMPLE: GetOpt {OpenDoors} {doors}
						--> Gets current status of the 'OpenDoors' VirindiTank option, and stores it in variable 'doors'.

		SetOpt   {s Option}   {s Expression}
				DETAILS: Two inputs. Sets the VirindiTank Option based upon the results of evaluating Expression.
				EXAMPLE: SetOpt {OpenDoors} {istrue[wobjectfindnearestdoor[]]}
						--> Sets the VirindiTank 'OpenDoors' option to true if any doors are nearby, false otherwise.

		CreateView   {s view Handle}   {s XML}
				DETAILS: Creates a Virindi View with the designated Handle, the layout of which is defined by XML. The XML
				must be on a single line (no line breaks). ---- Are other controls (etc.) recognized? I don't know. For a
				bit more, see: http://www.virindi.net/wiki/index.php/Meta_Views
				EXAMPLE: CreateView {myview} {<?xml version="1.0"?><view width="300" height="200" title="My View"><control type="layout"><control type="button" name="btnA1" left="20" top="10" width="50" height="20" text="B1" actionexpr="chatbox[\/vt echo B\1\!]" setstate="st"/></control></view>}
						--> Creates new Virindi View with handle 'myview' that makes a 300x200 window with title 'My View',
							and one 50x20 button with 'B1' text on it, at (20,10). Pressing it sets the state to 'st', and
							evaluates the expression 'chatbox[\/vt echo B1\!]'.

		DestroyView   {s View}
				DETAILS: Destroy the designated View.
				EXAMPLE: DestroyView {myview}
						--> Destroys the Virindi View with handle 'myview'.
						
		DestroyAllViews   (none)
				DETAILS: No inputs. Destroys all views for this meta.
				EXAMPLE: DestroyAllViews
						--> Destroys any views that exist for this meta.

	~~ NAV TYPES (NAV:)																										

		NAV:   l Tag   l Type
				DETAILS: Two inputs. Tag is only used as a 'handle' to uniquely identify a nav  as distinct from all other
				navs in the nav listing. Type is what type of nav it is. (See below.) Note that Tag can be anything you want
				it to be, so long as it's a valid literal and is distinct from all other nav tags. (There's no reason it
				needs to be nav## in format; it could just as easily be OlthoiMatronHive instead.)
				   circular - A navroute that infinitely repeats itself by looping back to the start when it hits the end.
					 linear - A navroute that infinitely repeats itself by alternatingly running it forward and backward.
					 follow - A navroute that is a single node in length (see below), to chase a specified player.
					   once - A navroute that does not repeat. Nodes are consumed (disappear) when they are reached.
				EXAMPLE: NAV: ToMyXPPlace once
							(Zero or more nav nodes appear on immediately following lines, tabbed in one time.)
						 --> Creates a navroute of type Once that is cited by meta code via the tag ToMyXPPlace.

	~~ NAV NODE FORMATS																										

				 Follow - flw   h Target GUID   {s Target Name}
				  Point - pnt   d X   d Y   d Z
							Colored more lightly because plain points tend to be 'the movement between the action'.
		   Recall Spell - rcl   d X   d Y   d Z   {s Full Name of Recall Spell}
							Recognized Full Recall Spell Names are, exactly:
								{Primary Portal Recall}					{Bur Recall}
								{Secondary Portal Recall}				{Paradox-touched Olthoi Infested Area Recall}
								{Lifestone Recall}						{Call of the Mhoire Forge}
								{Portal Recall}							{Lost City of Neftet Recall}
								{Recall Aphus Lassel}					{Return to the Keep}
								{Recall the Sanctuary}					{Facility Hub Recall}
								{Recall to the Singularity Caul}		{Colosseum Recall}
								{Glenden Wood Recall}					{Gear Knight Invasion Area Camp Recall}
								{Aerlinthe Recall}						{Rynthid Recall}
								{Mount Lethe Recall}					{Lifestone Sending}
								{Ulgrim's Recall}
				  Pause - pau   d X   d Y   d Z   d Pause (in ms)
		ChatField (any) - cht   d X   d Y   d Z   {s ChatInput}
			 Use Vendor - vnd   d X   d Y   d Z   h Target GUID   {s Target Name}
		 Use Portal/NPC - ptl   d X   d Y   d Z   d TargetX   d TargetY   d TargetZ   i Target ObjectClass   {s Target Name}
							Allowed ObjectClass: 14 (Portal), 37 (NPC), 10 (Container, e.g., 'Dangerous Portal Device').
		    Talk to NPC - tlk   d X   d Y   d Z   d TargetX   d TargetY   d TargetZ   i Target ObjectClass   {s Target Name}
							Allowed ObjectClass: 37 (NPC).
		 Nav Checkpoint - chk   d X   d Y   d Z
			   Nav Jump - jmp   d X   d Y   d Z   d HeadingInDegrees   {s HoldShift (True|False)}   d Delay (in ms)

~~																															
~~ 8. VIRINDITANK FUNCTIONS					http://www.virindi.net/wiki/index.php/Meta_Expressions#Function_Information		
~~																															

	~~ VARIABLES																											
		testvar[name]					touchvar[name]
		getvar[name]					clearallvars[]
		setvar[name,value]				clearvar[name]
		
	~~ CHARACTER   			Character properties http://www.virindi.net/wiki/index.php/Meta_Expressions#Object_Properties	
		getcharintprop[id]				wobjectgetplayer[]						getplayerlandcell[]
		getchardoubleprop[id]			getplayercoordinates[]					getcharvital_base[1H/2S/3M]
		getcharboolprop[id]				getcharskill_base[skillID]				getcharvital_current[1H/2S/3M]
		getcharquadprop[id]				getcharskill_buffed[skillID]			getcharvital_buffedmax[1H/2S/3M]
		getcharstringprop[id]			getcharskill_traininglevel[0Unuse/1Untrain/2Train/3Spec]	
		
	~~ CASTING   '/vt dumpspells'  http://www.virindi.net/wiki/index.php/Virindi_Tank_Commands#.2Fvt_commands_-_Game_Info	
		getisspellknown[spellID]		getcancastspell_hunt[spellID]			getcancastspell_buff[spellID]
		actiontryequipanywand[]			actiontrycastbyid[spellID]				actiontrycastbyidontarget[spellID,obj]
		
	~~ INVENTORY																											
		wobjectfindininventorybytemplatetype[templateTypeID]
		wobjectfindininventorybyname[name]
		wobjectfindininventorybynamerx[regex]
		
	~~ LOCATION																												
		getplayerlandcell[]					coordinategetns[coordObj]		coordinatedistancewithz[coordObj1,coordObj2]
		getplayercoordinates[]				coordinategetwe[coordObj]		coordinatedistanceflat[coordObj1,coordObj2]
		coordinatetostring[coordObj]		coordinategetz[coordObj]		wobjectgetphysicscoordinates[obj]
		coordinateparse[string]
		
	~~ OBJECT																												
		wobjectgetselection[]					wobjectgetname[obj]	
		wobjectgetplayer[]						wobjectgetphysicscoordinates[obj]	
		wobjectfindnearestmonster[]				wobjectfindnearestbyobjectclass[objClass]
		wobjectfindnearestdoor[]				wobjectfindnearestbynameandobjectclass[objClass,regex]
		wobjectgetisdooropen[doorObj]			wobjectfindininventorybyname[name]
		wobjectgetobjectclass[obj]				wobjectfindininventorybynamerx[regex]
		wobjectgettemplatetype[obj]				wobjectfindininventorybytemplatetype[templateTypeID]
		getobjectinternaltype[obj]
		
	~~ ACTION																												
		actiontryselect[obj]					actiontryequipanywand[]
		actiontryuseitem[obj]					actiontrycastbyid[spellID]
		actiontrygiveitem[obj,tgtObj]			actiontrycastbyidontarget[spellID,obj]
		actiontryapplyitem[useObj,tgtObj]
		
	~~ UI																													
		CHAT:			chatbox[string]							chatboxpaste[string]
		HUD, etc.:		statushud[key,val]						statushudcolored[key,val,intRGB]
						uigetcontrol[strWindow,strCtrl]			uisetlable[objCtrl,strLabel]
						
	~~ LOGIC																												
		iif[eval,retT,retF]				isfalse[obj]			istrue[obj]
		
	~~ NUMBER																												
		randint[minNumber,maxNumber]			round[number]				coordinategetns[coordObj]
		cstr[number]							abs[number]					coordinategetwe[coordObj]
		cstrf[realNumber,format(probably G)]	getcharintprop[id]			coordinategetz[coordObj]
		cnumber[string]							getchardoubleprop[id]                  
		floor[number]							getcharquadprop[id]
		ceiling[number]							getcharboolprop[id]
		
	~~ STRING																												
		cstr[number]							coordinatetostring[coordObj]
		strlen[string]							coordinateparse[string]
		cstrf[realNumber,format(probably G)]	wobjectgetname[obj]
		cnumber[string]							chatbox[strChatExpr]
		
	~~ TIME																													
		stopwatchcreate[]						stopwatchstop[watchObj]
		stopwatchstart[watchObj]				stopwatchelapsedseconds[watchObj]
		
	~~ MISCELLANEOUS																										
		getobjectinternaltype[obj]  (returns 0=none, 1=number, 3=string, 7=object)

~~																															
~~	I hope you find metaf helpful in your meta-making adventures!   ~ Eskarina												
~~																															

~~																															
~~		METa Alternate Format																					Created by	
~~			documentation																						 Eskarina	
~~																															
